import data.matrix.notation
import algebra.group_power

universe variables u v

namespace first_order

section language

/- Definition of a language -/
structure language :=
(functions : ‚Ñï ‚Üí Type) (relations : ‚Ñï ‚Üí Type)

/-- The empty language has no symbols. -/
def empty : language := ‚ü®Œª _, pempty, Œª _, pempty‚ü©

instance : inhabited language := ‚ü®empty‚ü©

/-- The type of constants in a given language. -/
def const (L : language) := L.functions 0

variable (L : language)

/-- Def 1.3.1. A term of a language-/
inductive term
| var           : ‚Ñï ‚Üí term
| func {n : ‚Ñï}  : L.functions n ‚Üí (fin n ‚Üí term) ‚Üí term

open term

/- A formula of a language -/
inductive formula
| falsum      : formula
| eq          : @term L ‚Üí @term L ‚Üí formula
| rel {n : ‚Ñï} : L.relations n ‚Üí (fin n ‚Üí @term L) ‚Üí formula
| neg         : formula ‚Üí formula
| or          : formula ‚Üí formula ‚Üí formula
| all         : ‚Ñï ‚Üí formula ‚Üí formula

/- Quantifier free formulas -/
inductive qf
| f           : qf
| e           : term L ‚Üí term L ‚Üí qf
| r {n : ‚Ñï}   : L.relations n ‚Üí (fin n ‚Üí term L) ‚Üí qf
| n           : qf ‚Üí qf
| o           : qf ‚Üí qf ‚Üí qf

def qf_to_formula : qf L ‚Üí formula L 
| qf.f         := formula.falsum
| (qf.e s t)   := formula.eq s t
| (qf.r r a)   := formula.rel r a
| (qf.n œÜ)     := formula.neg (qf_to_formula œÜ)
| (qf.o œÜ‚ÇÅ œÜ‚ÇÇ) := formula.or (qf_to_formula œÜ‚ÇÅ) (qf_to_formula œÜ‚ÇÇ)

instance qf_to_formula_coe (L : language) :
  has_coe (qf L) (formula L) :=
  ‚ü®qf_to_formula L‚ü©

notation ` v `    := term.var
notation ` v‚ÇÄ `   := term.var 0
notation ` v‚ÇÅ `   := term.var 1
notation ` v‚ÇÇ `   := term.var 2
notation ` v‚ÇÉ `   := term.var 3
notation ` v‚ÇÑ `   := term.var 4
notation ` v‚ÇÖ `   := term.var 5

notation ` F `        := formula.falsum
notation ` T `        := formula.neg F
infix ` ‚âÉ `:88        := formula.eq
prefix ` ‚àº `:100      := formula.neg
infix  ` or `:50      := formula.or
notation œÜ‚ÇÅ` and `œÜ‚ÇÇ  := ‚àº(‚àºœÜ‚ÇÅ or ‚àºœÜ‚ÇÇ)
notation œÜ‚ÇÅ` ‚áí `œÜ‚ÇÇ    := ‚àºœÜ‚ÇÅ or œÜ‚ÇÇ
notation œÜ‚ÇÅ` ‚áî `œÜ‚ÇÇ   := (œÜ‚ÇÅ ‚áí œÜ‚ÇÇ) and (œÜ‚ÇÇ ‚áí œÜ‚ÇÅ)
notation ` all `       := formula.all
notation ` exi `       := Œª n œÜ, ‚àº(formula.all n ‚àºœÜ)

open formula

variables (Œ± : language ‚Üí Type) (œÜ œÜ‚ÇÅ œÜ‚ÇÇ h : formula L) (t Œ¶‚ÇÅ Œ¶‚ÇÇ : list (formula L)) (n : ‚Ñï) 

/- Atomic formulas-/
inductive atom
| f           : atom
| e           : term L ‚Üí term L ‚Üí atom 
| r {n : ‚Ñï}   : L.relations n ‚Üí (fin n ‚Üí term L) ‚Üí atom

@[simp]
def atom_to_qf : atom L ‚Üí qf L
| atom.f               := qf.f
| (atom.e t s)         := qf.e t s
| (atom.r rsymb args)  := qf.r rsymb args

/- Literals -/
inductive lit
| a      : atom L ‚Üí lit
| na     : atom L ‚Üí lit

/- Negate a literal -/
@[simp]
def neg_lit : lit L ‚Üí lit L
| (lit.a œÜ)  := lit.na œÜ
| (lit.na œÜ) := lit.a œÜ

@[simp]
def atom_to_lit : atom L ‚Üí lit L
| a := lit.a a

@[reducible]
instance atom_to_lit_coe (L : language) :
  has_coe (atom L) (lit L) :=
  ‚ü®atom_to_lit L‚ü©

@[simp]
def lit_to_qf : lit L ‚Üí qf L
| (lit.a a)   := atom_to_qf _ a
| (lit.na na) := qf.n (atom_to_qf _ na)

/- Conjunctions of literals -/
inductive cl
| l        : lit L ‚Üí cl 
| c        : cl ‚Üí cl ‚Üí cl

@[simp]
def lit_to_cl : lit L ‚Üí cl L
| l := cl.l l

@[reducible]
instance lit_to_cl_coe (L : language) :
  has_coe (lit L) (cl L) :=
  ‚ü®lit_to_cl L‚ü©

@[simp]
def cl_to_qf : cl L ‚Üí qf L
| (cl.l l)        := lit_to_qf _ l
| (cl.c cl‚ÇÅ cl‚ÇÇ)  := qf.n (qf.o (qf.n (cl_to_qf cl‚ÇÅ)) (qf.n (cl_to_qf cl‚ÇÇ)))

/- Disjunctions of conjunctions of literals -/
inductive dcl
| cl : cl L ‚Üí dcl
| d  : dcl ‚Üí dcl ‚Üí dcl

@[simp]
def cl_to_dcl : cl L ‚Üí dcl L
| cl := dcl.cl cl

@[reducible]
instance cl_to_dcl_coe (L : language) :
  has_coe (cl L) (dcl L) :=
  ‚ü®cl_to_dcl L‚ü©

@[simp]
def dcl_to_qf : dcl L ‚Üí qf L
| (dcl.cl cl)       := cl_to_qf _ cl
| (dcl.d dcl‚ÇÅ dcl‚ÇÇ) := qf.o (dcl_to_qf dcl‚ÇÅ) (dcl_to_qf dcl‚ÇÇ)

@[reducible]
instance dcl_to_qf_coe (L : language) :
  has_coe (dcl L) (qf L) :=
  ‚ü®dcl_to_qf L‚ü©

/- Disjunctive normal form -/
inductive dnf
| dcl  : dcl L ‚Üí dnf
| al   : ‚Ñï ‚Üí dnf ‚Üí dnf
| ex   : ‚Ñï ‚Üí dnf ‚Üí dnf

@[simp]
def dcl_to_dnf : dcl L ‚Üí dnf L
| dcl := dnf.dcl dcl

@[reducible]
instance dcl_to_dnf_coe (L : language) :
  has_coe (dcl L) (dnf L) :=
  ‚ü®dcl_to_dnf L‚ü©

@[simp]
def dnf_to_formula : dnf L ‚Üí formula L 
| (dnf.dcl dcl)  := qf_to_formula _ (dcl_to_qf _ dcl)
| (dnf.al n dnf) := all n (dnf_to_formula dnf)
| (dnf.ex n dnf) := exi n (dnf_to_formula dnf)

@[reducible]
instance dnf_to_formula_coe (L : language) :
  has_coe (dnf L) (formula L) :=
  ‚ü®dnf_to_formula L‚ü©

/- A single quantifier on a conjunction of literals -/
inductive qcl1
| cl : cl L ‚Üí qcl1
| al : ‚Ñï ‚Üí cl L ‚Üí qcl1
| ex : ‚Ñï ‚Üí cl L ‚Üí qcl1

/- A series of quantifiers on a conjunction of literals -/
inductive qcl
| cl : cl L ‚Üí qcl
| al : ‚Ñï ‚Üí qcl ‚Üí qcl
| ex : ‚Ñï ‚Üí qcl ‚Üí qcl

@[simp]
def qcl1_to_qcl : qcl1 L ‚Üí qcl L
| (qcl1.cl cl)   := qcl.cl cl
| (qcl1.al n cl) := qcl.al n (qcl.cl cl)
| (qcl1.ex n cl) := qcl.ex n (qcl.cl cl)

@[reducible]
instance qcl1_to_qcl_coe (L : language) :
  has_coe (qcl1 L) (qcl L) :=
  ‚ü®qcl1_to_qcl L‚ü©

@[simp]
def qcl_to_formula : qcl L ‚Üí formula L
| (qcl.cl cl)    := qf_to_formula _ (cl_to_qf _ cl)
| (qcl.al n qcl) := (all n (qcl_to_formula qcl))
| (qcl.ex n qcl) := (exi n (qcl_to_formula qcl))

/- A disjunction of qcl -/
inductive dqcl
| qcl : qcl L ‚Üí dqcl
| d   : dqcl ‚Üí dqcl ‚Üí dqcl

@[simp]
def qcl_to_dqcl : qcl L ‚Üí dqcl L 
| qcl := dqcl.qcl qcl

@[reducible]
instance qcl_to_dqcl_coe (L : language) :
  has_coe (qcl L) (dqcl L) :=
  ‚ü®qcl_to_dqcl L‚ü©

@[simp]
def dqcl_to_formula : dqcl L ‚Üí formula L
| (dqcl.qcl qcl)       := qcl_to_formula _ qcl
| (dqcl.d dqcl‚ÇÅ dqcl‚ÇÇ) := (dqcl_to_formula dqcl‚ÇÅ) or (dqcl_to_formula dqcl‚ÇÇ)

@[reducible]
instance dqcl_to_formula_coe (L : language) :
  has_coe (dqcl L) (formula L) :=
  ‚ü®dqcl_to_formula L‚ü©

/- A single quantifier on a disjunction of conjunction of literals -/
inductive qdcl1
| dcl : dcl L ‚Üí qdcl1
| al  : ‚Ñï ‚Üí dcl L ‚Üí qdcl1
| ex  : ‚Ñï ‚Üí dcl L ‚Üí qdcl1

@[simp]
def qcl1_to_qdcl1 : qcl1 L ‚Üí qdcl1 L 
| (qcl1.cl cl)   := qdcl1.dcl (dcl.cl cl)
| (qcl1.al n cl) := qdcl1.al n (dcl.cl cl)
| (qcl1.ex n cl) := qdcl1.ex n (dcl.cl cl)

@[reducible]
instance qcl1_to_qdcl1_coe (L : language) :
  has_coe (qcl1 L) (qdcl1 L) :=
  ‚ü®qcl1_to_qdcl1 L‚ü©

@[simp]
def qdcl1_to_dnf : qdcl1 L ‚Üí dnf L
| (qdcl1.dcl dcl)  := dnf.dcl dcl
| (qdcl1.al n dcl) := dnf.al n (dnf.dcl dcl)
| (qdcl1.ex n dcl) := dnf.ex n (dnf.dcl dcl)

@[reducible]
instance qdcl1_to_dnf_coe (L : language) :
  has_coe (qdcl1 L) (dnf L) :=
  ‚ü®qdcl1_to_dnf L‚ü©

/- If a variable occurs in a term -/
def occurs_in_term (n : ‚Ñï) : term L ‚Üí Prop
| (v m)        := n = m
| (func _ t)   := ‚àÉ i, occurs_in_term (t i)

notation n \ t     := occurs_in_term _ n t

/- Def 1.5.2. If a variable is free in a formula -/
def free (n : ‚Ñï) : formula L ‚Üí Prop
| F                 := false
| (t‚ÇÅ ‚âÉ t‚ÇÇ)         := (occurs_in_term L n t‚ÇÅ) ‚à® (occurs_in_term L n t‚ÇÇ)
| (rel rsymb args)  := ‚àÉ i, occurs_in_term L n (args i)
| ‚àºœÜ                := free œÜ
| (œÜ‚ÇÅ or œÜ‚ÇÇ)        := free œÜ‚ÇÅ ‚à® free œÜ‚ÇÇ
| (all m œÜ)         := !(n = m) ‚àß free œÜ

def var_not_free_in (n : ‚Ñï) : list (formula L) ‚Üí Prop
| list.nil             := true
| (list.cons h t)      := ¬¨(free _ n h) ‚àß (var_not_free_in t)

/-- Def 1.8.1. The term with the variable x replaced by the term t -/
def replace_term_with (x : ‚Ñï) (t : term L) : term L ‚Üí term L
| (v n)              := if (n = x) then t else (v n)
| (func fsymb args)  := (func fsymb (Œª n, replace_term_with (args n)))

/-- Def 1.8.2. The formula with the variable x replaced the term t -/
def replace_formula_with (x : ‚Ñï) (t : term L) : formula L ‚Üí formula L
| F                  := falsum
| (t‚ÇÅ ‚âÉ t‚ÇÇ)          := (replace_term_with _ x t t‚ÇÅ) ‚âÉ (replace_term_with _ x t t‚ÇÇ)
| (rel rsymb args)    := rel rsymb (Œª n, replace_term_with _ x t (args n))
| ‚àºœÜ                  := ‚àº(replace_formula_with œÜ)
| (œÜ‚ÇÅ or œÜ‚ÇÇ)          := (replace_formula_with œÜ‚ÇÅ) or (replace_formula_with œÜ‚ÇÇ)
| (all y œÜ)           := if x = y then (all y œÜ) else (all y (replace_formula_with œÜ))

/-- The term t is substitutable for the variable x in formula œÜ -/
def substitutable_for (x : ‚Ñï) (t : term L) : formula L ‚Üí Prop
| F                    := true
| (_ ‚âÉ _)              := true
| (rel _ _)            := true
| ‚àºœÜ                   := substitutable_for œÜ
| (œÜ‚ÇÅ or œÜ‚ÇÇ)           := (substitutable_for œÜ‚ÇÅ) ‚àß (substitutable_for œÜ‚ÇÇ)
| (all y œÜ)            := ¬¨(free _ x œÜ) ‚à® (¬¨(occurs_in_term _ y t) ‚àß (substitutable_for œÜ))

/-- The sentences of a language -/
def sentence : set (formula L) := Œª œÜ, ‚àÄ n : ‚Ñï, ¬¨(free L n œÜ)

end language

section Structure

open term
open formula

variables (L : language) (A : Type*)

/- An L-structure -/
structure Structure :=
(functions : Œ† {n : ‚Ñï}, L.functions n ‚Üí (fin n ‚Üí A) ‚Üí A)
(relations : Œ† {n : ‚Ñï}, L.relations n ‚Üí (fin n ‚Üí A) ‚Üí Prop)

variable ùî∏ : Structure L A

/- Variable assignment function into A -/
def var_assign := ‚Ñï ‚Üí A

/- x-modification of the assignment function s -/
def modification_of (s : var_assign A) (x : ‚Ñï) (a : A) : var_assign A :=
  Œª (n : ‚Ñï), if n = x then a else s n

notation s `[`x`|`a`]` := modification_of _ s x a

/-- Term assignment function -/
def term_assign := term L ‚Üí A

/- The term assignment function induced by the variable assignment function s -/
def term_assign_of_s (s : var_assign A) : term_assign L A
| (v n)                 := s n
| (func fsymb args)     := ùî∏.functions fsymb (Œª n, term_assign_of_s (args n))

@[reducible]
instance : has_coe (var_assign A) (term_assign L A) := ‚ü®term_assign_of_s _ _ ùî∏‚ü©

notation ` * ` := term_assign_of_s _ _

/- Variable assignments agree on free variables of a term -/
def agree_on_free_variables (s‚ÇÅ s‚ÇÇ : var_assign A)(t : term L) : Prop := ‚àÄ n : ‚Ñï, occurs_in_term _ n t ‚Üí s‚ÇÅ n = s‚ÇÇ n

/- A structure ùî∏ satisfies formula œÜ with assignment s -/
def satisfies_with_assignment : var_assign A ‚Üí formula L ‚Üí Prop
  | s F                   := false
  | s (t‚ÇÅ ‚âÉ t‚ÇÇ)           := (* ùî∏ s) t‚ÇÅ = (* ùî∏ s) t‚ÇÇ
  | s (rel rsymb args)    := ùî∏.relations rsymb (Œª n, (* ùî∏ s) (args n))
  | s ‚àºœÜ‚ÇÅ                 := ¬¨(satisfies_with_assignment s œÜ‚ÇÅ)
  | s (œÜ‚ÇÅ or œÜ‚ÇÇ)          := (satisfies_with_assignment s œÜ‚ÇÅ) ‚à® (satisfies_with_assignment s œÜ‚ÇÇ)
  | s (all n œÜ‚ÇÅ)          := ‚àÄ a : A, satisfies_with_assignment (s[n|a]) œÜ‚ÇÅ

notation ùî∏` ‚ä® `œÜ` | `s:= satisfies_with_assignment _ _ ùî∏ s œÜ

variable s : var_assign A

-- Decidable instances for ‚ä®
instance eq_decidable [decidable_eq A]: ‚àÄ n m : ‚Ñï, decidable (ùî∏ ‚ä® (v n  ‚âÉ v m) | s) := begin
intros n m,
rw satisfies_with_assignment,
apply_instance,
end

instance not_decidable {œÜ : formula L} [decidable (ùî∏ ‚ä® œÜ | s)] : decidable (ùî∏ ‚ä® ‚àºœÜ | s) := begin
rw satisfies_with_assignment,
apply_instance,
end

instance or_decidable {œÜ‚ÇÅ œÜ‚ÇÇ : formula L} [decidable (ùî∏ ‚ä® œÜ‚ÇÅ | s)] [decidable (ùî∏ ‚ä® œÜ‚ÇÇ | s)] : decidable (ùî∏ ‚ä® (œÜ‚ÇÅ or œÜ‚ÇÇ) | s) := begin
rw satisfies_with_assignment,
apply_instance,
end

/- A structure ùî∏ satisfies a formula i.e. is a model of the formula -/
def satisfies_formula (œÜ : formula L) : Prop := 
  ‚àÄ s : var_assign A, ùî∏ ‚ä® œÜ | s 

notation ùî∏` ‚ä® `œÜ       := satisfies_formula _ _ ùî∏ œÜ

/- A structure ùî∏ satisfies a set of formulas -/
def satisfies_set_formula (Œì : set (formula L)) : Prop :=
  ‚àÄ œÜ ‚àà Œì, ùî∏ ‚ä® œÜ

notation ùî∏` ‚ä® `Œì          := satisfies_set_formula _ _ ùî∏ Œì

/- Logical implication in a structure -/
def logically_implies (Œî Œì : set (formula L)) : Prop :=
  ‚àÄ (A : Type*) (ùî∏ : Structure L A), (ùî∏ ‚ä® Œî) ‚Üí (ùî∏ ‚ä® Œì)

notation Œî` ‚ä® `Œì         := logically_implies _ _ Œî Œì

-- A set of formula is valid if it is true in all structures 
-- with every assignment funciton
notation ` ‚ä® `Œì          := logically_implies _ _ ‚àÖ Œì

variables (s‚ÇÅ s‚ÇÇ : var_assign A) (t : term L) (œÜ : formula L)

end Structure

end first_order